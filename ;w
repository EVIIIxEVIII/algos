#include <bits/stdc++.h>
using namespace std;

long long mod_pow(long long q, long long e, long long p) {
    long long r = 1 % p;
    q %= p;
    while (e) {
        if (e & 1) r = r * q % p;
        q = q * q % p;
        e >>= 1;
    }
    return r;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    constexpr long long M = 998244353;
    vector<array<int, 4>> s;

    for (int i = 0; i < n; ++i) {
        int l, r, p, q;
        cin >> l >> r >> p >> q;
        s.push_back({l, r, p, q});
    }

    // idea: to get the probability of some segment i, we need to know
    // the sum of the probabilities that all the cells before it are covered
    // and then multiply that value to the probability of the segment.
    //
    // the probability that some segment [l, r] will be used is equal to the
    // sum of probabilities that there is a segment that ends at l-1 times
    // the probability of the segment
    //
    // so the value at dp[r] will be equal to dp[l-1] * probability of the segment
    // [l, r]?
    //
    // also I will need this: a^(p-2) = a^(-1) mod p

    vector<vector<array<int,4>>> by_r(m+1);

    for (auto& seg : s) {
        by_r[seg[1]].push_back(seg);
    }

    vector<int> dp(m+1, 0);
    dp[0] = 1;

    vector<int> probs(m+1, 1);
    probs[0] = 1;
    for (auto& [l, r, p, q] : s) {
        long long inv_q = mod_pow(q, M - 2, M);
        long long prob = (q - p) % M * inv_q % M; // inverse (q - p) / q = 1 - p / q
        probs[r] *= prob * M;
    }

    for (int i = 1; i <= m; ++i) {
        probs[i] *= probs[i-1] % M;
    }

    for (int r = 1; r <= m; ++r) {
        for (auto& [l, _, p, q] : by_r[r]) {
            long long inv_q = mod_pow(q, M - 2, M);
            long long prob = p % M * inv_q % M;

            long long inverse_prob = (q - p) % M * inv_q % M;
            long long no_interference =
                probs[r] * mod_pow(probs[l], M - 2, M) * mod_pow(inverse_prob, M - 2, M) % M;

            dp[r] = (dp[r] + dp[l-1] * prob) % M * no_interference % M;
        }
    }

    cout << dp[m] << '\n';

    return 0;
}
